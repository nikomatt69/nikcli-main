apiVersion: v1
kind: ConfigMap
metadata:
  name: virtualized-agents-config
  namespace: default # Adjust to your namespace for multi-tenant setups
  labels:
    app: virtualized-agents
    tier: enterprise
    env: production # Use for filtering in selectors (e.g., HPA)
  annotations:
    description: "Enterprise config template for virtualized agents. Mount as volume in Deployments."
    config.typescript.interface: |
      // Sample TypeScript interface for typed config loading (e.g., via yaml.load() + this interface)
      interface AgentConfig {
        scaling: {
          minReplicas: number;
          maxReplicas: number;
          hpaMetrics: Array<{ type: 'cpu' | 'memory'; threshold: number }>;
        };
        authentication: {
          type: 'oauth' | 'jwt' | 'basic';
          secretRef: { name: string; key: string };
          enabled: boolean;
        };
        resources: {
          requests: { cpu: string; memory: string };
          limits: { cpu: string; memory: string };
          quotas: { namespaceCpu: string; namespaceMemory: string };
          retryConfig?: { maxRetries: number; backoffMs: number };  // Error handling enhancement
        };
        logging: {
          level: 'debug' | 'info' | 'warn' | 'error';
          format: 'json' | 'text';
          destination: string;  // e.g., 'stdout' for Kubernetes logs
        };
        integrations: Array<{
          name: string;
          type: 'db' | 'api' | 'queue';
          url: string;
          envVars?: Array<{ name: string; value: string }>;
          volumeMount?: { path: string; secretRef?: string };
          hook?: string;  // Integration hook: Custom callback URL or function ref
        }>;
      }
      // Usage: const config: AgentConfig = yaml.load(fs.readFileSync('config.yaml', 'utf8'));
---
data:
  agent-config.yaml: |
    # Enterprise Configuration Template for Virtualized Agents
    # This YAML is mounted into agent pods via ConfigMap volume.
    # Validate with a schema tool (e.g., kubeval or custom YAML schema) before production use.
    # Version: 1.0.0

    scaling:
      # Horizontal Pod Autoscaler (HPA) integration for auto-scaling based on load.
      # Kubernetes Pattern: Reference this in HPA spec (e.g., targetCPUUtilizationPercentage).
      minReplicas: 2  # Minimum number of agent pods; prevents under-provisioning.
      maxReplicas: 15  # Increased from 10 for enhanced scalability
      hpaMetrics:
        # Complex logic: HPA scales if CPU > threshold for 5min (default stabilization window).
        # Adjust thresholds for your workload; monitor via kubectl top.
        - type: cpu
          threshold: 70  # % utilization; triggers scale-up.
        - type: memory
          threshold: 80  # % utilization; for memory-intensive agents.

    authentication:
      # Secure auth for agents accessing enterprise services.
      # Kubernetes Pattern: Use Secret resources for sensitive data (e.g., kubectl create secret generic agent-oauth --from-literal=token=xyz).
      # Never hardcode secrets here; always reference.
      type: oauth  # Options: 'oauth', 'jwt', 'basic'. Use 'oauth' for enterprise SSO.
      enabled: true  # Disable in dev; always true in prod.
      secretRef:
        name: agent-auth-secret  # Name of the Kubernetes Secret.
        key: oauth-token  # Key within the Secret holding the token.
      # Complex logic: On pod startup, agents load token from mounted Secret volume.
      # RBAC Recommendation: Add ClusterRoleBinding for agents to read Secrets in their namespace.
      rbac:
        role: reader  # Minimal permissions; use 'editor' for write access.
        namespace: default

    resources:
      # Pod-level resource management to ensure QoS (Quality of Service).
      # Kubernetes Pattern: Apply to Deployment spec.template.spec.containers.resources.
      # Use Guaranteed QoS class for critical agents (requests == limits).
      requests:
        cpu: "250m"  # Minimum CPU; prevents scheduling on low-resource nodes.
        memory: "256Mi"  # Minimum memory; adjust based on agent workload.
      limits:
        cpu: "500m"  # Hard cap; evicts pod if exceeded (OOMKilled).
        memory: "512Mi"  # Hard cap; prevents memory leaks from starving cluster.
      # Complex logic: Namespace quotas enforce enterprise limits (create ResourceQuota CR).
      quotas:
        namespaceCpu: "10"  # Total CPU cores for all agents in namespace.
        namespaceMemory: "20Gi"  # Total memory; monitor with kubectl describe quota.
      # Error handling enhancement: Retry config for agent operations
      retryConfig:
        maxRetries: 3  # Max retry attempts for flaky operations
        backoffMs: 1000  # Initial backoff in ms (exponential)

    logging:
      # Structured logging for observability in enterprise environments.
      # Kubernetes Pattern: Output to stdout/stderr; collect with DaemonSet like Fluentd or Loki.
      level: info  # Options: 'debug' (verbose, dev-only), 'info', 'warn', 'error' (prod default).
      format: json  # 'json' for parsing in ELK stack; 'text' for simple logs.
      destination: stdout  # 'stdout' integrates with K8s logs (kubectl logs); alt: 'file:/var/log/agents.log'.
      # Complex logic: Rotate logs via sidecar if destination is file (use Kubernetes EmptyDir volume).
      # Retention: Configure cluster-wide (e.g., 7 days) via logging operator.
      maxFileSize: "10MB"  # If using file destination; prevents disk exhaustion.
      retentionDays: 7

    integrations:
      # Hook points for external services (e.g., DB, APIs, message queues).
      # Kubernetes Pattern: Use envFrom/ConfigMap for vars; PersistentVolume for stateful integrations.
      # Populate dynamically via Helm values or Kustomize overlays for multi-env.
      - name: database
        type: db  # 'db', 'api', 'queue'.
        url: "postgresql://db-service:5432/agentsdb"  # Service discovery via K8s DNS.
        envVars:
          - name: DB_USER
            value: "agent-user"  # Reference Secret for prod (valueFrom.secretKeyRef).
          - name: DB_PASSWORD
            valueFrom:
              secretKeyRef:
                name: db-secret
                key: password
        volumeMount:
          path: /data/db  # Mount for persistent storage if needed.
          secretRef: db-credentials  # Optional: Mount Secrets as files.
        hook: "/integrate/db-callback"  # Integration hook: Endpoint for post-operation callbacks
      - name: api-gateway
        type: api
        url: "https://api.internal:443/v1"
        # Complex logic: Health checks via readinessProbe in Deployment; retry on failure.
        timeout: 30s  # Connection timeout; use circuit breaker in agent code.
        envVars:
          - name: API_KEY
            valueFrom:
              secretKeyRef:
                name: api-secret
                key: key
        hook: "custom-api-hook"  # Integration hook: Custom function or URL ref
      - name: message-queue
        type: queue
        url: "kafka://mq-service:9092"
        # Add more as needed; scale integrations independently via separate Deployments.
        hook: ""  # Optional hook for queue events
