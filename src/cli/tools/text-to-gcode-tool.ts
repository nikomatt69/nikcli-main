import fs from 'node:fs/promises'
import path from 'node:path'
import chalk from 'chalk'
import { z } from 'zod'
import { BaseTool, type ToolExecutionResult } from './base-tool'

export const GCodeGenerationOptionsSchema = z.object({
  description: z.string().min(1, 'Description must not be empty'),
})

export type GCodeGenerationParams = z.infer<typeof GCodeGenerationOptionsSchema>

export interface GCodeGenerationData {
  gcode: string
  filePath: string
}

interface ToolConfig {
  name: string
  diameterMm: number
  feedXY: number
  feedZ: number
  stepDown: number
  safeZ: number
  spindleRPM?: number
}

export class TextToGCodeTool extends BaseTool {
  private defaultTool: ToolConfig
  constructor(workingDirectory: string) {
    super('text-to-gcode-tool', workingDirectory)
    // Default tool used implicitly during generation (not emitted in header)
    this.defaultTool = {
      name: 'default-endmill-6mm',
      diameterMm: 6,
      feedXY: 600,
      feedZ: 300,
      stepDown: 1,
      safeZ: 5,
      spindleRPM: 12000,
    }
  }

  async execute(params: GCodeGenerationParams): Promise<ToolExecutionResult> {
    const start = Date.now()
    try {
      const validated = GCodeGenerationOptionsSchema.parse(params)
      console.log(chalk.blue(`⚙️ Generating G-code for: "${validated.description}"`))

      const gcode = this.generateBasicGcode(validated.description)
      const filePath = await this.saveGcodeToFile(gcode, validated.description)
      const data: GCodeGenerationData = { gcode, filePath }

      return {
        success: true,
        data,
        metadata: {
          executionTime: Date.now() - start,
          toolName: this.getName(),
          parameters: validated,
        },
      }
    } catch (error: any) {
      return {
        success: false,
        data: {},
        error: error.message,
        metadata: {
          executionTime: Date.now() - start,
          toolName: this.getName(),
          parameters: params,
        },
      }
    }
  }

  private generateBasicGcode(description: string): string {
    const job = this.parseJobFromDescription(description)

    const lines: string[] = []
    // Header
    lines.push('; -------------------------------------------')
    lines.push('; G-code generated by NikCLI')
    lines.push(`; Description: ${description}`)
    lines.push(`; Operation: ${job.type}`)
    lines.push('; Units: millimeters')
    lines.push('; Coordinate mode: absolute')
    lines.push('; Plane: XY (G17)')
    lines.push('; -------------------------------------------')
    lines.push('G21        ; set units to millimeters')
    lines.push('G90        ; absolute positioning')
    lines.push('G17        ; XY plane selection')
    lines.push('G54        ; use work coordinate system 1')
    lines.push(`G0 Z${job.params.safeZ.toFixed(3)}   ; move to safe height`)

    // Body
    switch (job.type) {
      case 'rectangle':
        lines.push(...this.generateRectangleProfile(job.params))
        break
      case 'pocket':
        lines.push(...this.generatePocket(job.params))
        break
      case 'circle':
        lines.push(...this.generateCircleProfile(job.params))
        break
      case 'drill':
        lines.push(...this.generateDrillPattern(job.params))
        break
      default:
        lines.push(...this.generateRectangleProfile(job.params))
        break
    }

    // Footer
    lines.push(`G0 Z${job.params.safeZ.toFixed(3)}   ; retract to safe height`)
    lines.push('G0 X0 Y0   ; return to origin')
    lines.push('M5         ; stop spindle (if applicable)')
    lines.push('M2         ; program end')
    return lines.join('\n')
  }

  private parseJobFromDescription(description: string): {
    type: 'rectangle' | 'circle' | 'drill' | 'pocket' | 'unknown'
    params: {
      width?: number
      height?: number
      diameter?: number
      radius?: number
      depth: number
      safeZ: number
      feedXY: number
      feedZ: number
      stepDown: number
      holes?: number
      rows?: number
      cols?: number
      spacing?: number
    }
  } {
    const text = (description || '').toLowerCase()
    const params = {
      width: undefined as number | undefined,
      height: undefined as number | undefined,
      diameter: undefined as number | undefined,
      radius: undefined as number | undefined,
      depth: this.extractNumber(text, /(depth|deep|z)\s*([-+]?\d+(?:\.\d+)?)\s*mm/) ?? 2,
      safeZ: this.defaultTool.safeZ,
      feedXY: this.defaultTool.feedXY,
      feedZ: this.defaultTool.feedZ,
      stepDown: this.defaultTool.stepDown,
      holes: undefined as number | undefined,
      rows: undefined as number | undefined,
      cols: undefined as number | undefined,
      spacing: undefined as number | undefined,
    }

    // Dimensions like 100x50, 100 x 50 mm
    const rectMatch = text.match(/(\d+(?:\.\d+)?)\s*[x×]\s*(\d+(?:\.\d+)?)(?:\s*mm)?/)
    if (rectMatch) {
      params.width = parseFloat(rectMatch[1])
      params.height = parseFloat(rectMatch[2])
    }

    // Explicit width/height
    const wMatch = text.match(/(width|larghezza)\s*(\d+(?:\.\d+)?)\s*mm/)
    const hMatch = text.match(/(height|altezza)\s*(\d+(?:\.\d+)?)\s*mm/)
    if (wMatch) params.width = parseFloat(wMatch[2])
    if (hMatch) params.height = parseFloat(hMatch[2])

    // Diameter / radius
    const dMatch = text.match(/(diameter|diametro)\s*(\d+(?:\.\d+)?)\s*mm/)
    const rMatch = text.match(/(radius|raggio)\s*(\d+(?:\.\d+)?)\s*mm/)
    if (dMatch) params.diameter = parseFloat(dMatch[2])
    if (rMatch) params.radius = parseFloat(rMatch[2])
    if (!params.radius && params.diameter) params.radius = params.diameter / 2
    if (!params.diameter && params.radius) params.diameter = params.radius * 2

    // Depth
    const depthMatch = text.match(/(depth|deep|profondit[àa]|z)\s*(\d+(?:\.\d+)?)\s*mm/)
    if (depthMatch) params.depth = parseFloat(depthMatch[2])

    // Holes and grid
    const holesMatch = text.match(/(\d+)\s+holes?/) || text.match(/fori?\s+(\d+)/)
    if (holesMatch) params.holes = parseInt(holesMatch[1])
    const gridMatch = text.match(/(\d+)\s*[x×]\s*(\d+)\s*(grid|pattern)?/)
    if (gridMatch) {
      params.rows = parseInt(gridMatch[1])
      params.cols = parseInt(gridMatch[2])
      if (params.holes === undefined) params.holes = params.rows * params.cols
    }
    const spacingMatch = text.match(/(spacing|pitch|interasse)\s*(\d+(?:\.\d+)?)\s*mm/)
    if (spacingMatch) params.spacing = parseFloat(spacingMatch[2])

    // Operation type heuristics
    let type: 'rectangle' | 'circle' | 'drill' | 'pocket' | 'unknown' = 'unknown'
    if (/pocket|tasca|cavity|scavare/.test(text)) type = 'pocket'
    else if (/drill|forare|fori|holes?/.test(text)) type = 'drill'
    else if (/circle|circular|ring|cerchio/.test(text)) type = 'circle'
    else if (/rect|square|plate|rettangolo|quadrato|piastra/.test(text)) type = 'rectangle'

    // Reasonable defaults
    if (!params.width) params.width = params.diameter ? params.diameter : 20
    if (!params.height) params.height = params.diameter ? params.diameter : params.width
    if (!params.radius && type === 'circle') params.radius = Math.min(params.width, params.height) / 2

    return { type, params }
  }

  private extractNumber(text: string, regex: RegExp): number | null {
    const m = text.match(regex)
    if (m) return parseFloat(m[2])
    return null
  }

  private generateRectangleProfile(params: {
    width?: number
    height?: number
    depth: number
    safeZ: number
    feedXY: number
    feedZ: number
    stepDown: number
  }): string[] {
    const width = Math.max(1, Math.round((params.width ?? 20) * 1000) / 1000)
    const height = Math.max(1, Math.round((params.height ?? 20) * 1000) / 1000)
    const totalDepth = Math.max(0.5, params.depth)
    const step = Math.max(0.5, Math.min(params.stepDown, totalDepth))
    const passes = Math.ceil(totalDepth / step)

    const lines: string[] = []
    lines.push(`; Rectangle profile: ${width} x ${height} mm, depth ${totalDepth} mm`)
    for (let i = 1; i <= passes; i++) {
      const z = -Math.min(i * step, totalDepth)
      lines.push(`; Pass ${i}/${passes} to Z${z.toFixed(3)}`)
      lines.push('G0 X0 Y0')
      lines.push(`G1 Z${z.toFixed(3)} F${params.feedZ}`)
      lines.push(`G1 X${width.toFixed(3)} Y0 F${params.feedXY}`)
      lines.push(`G1 X${width.toFixed(3)} Y${height.toFixed(3)}`)
      lines.push(`G1 X0 Y${height.toFixed(3)}`)
      lines.push('G1 X0 Y0')
      lines.push(`G0 Z${params.safeZ.toFixed(3)}`)
    }
    return lines
  }

  private generatePocket(params: {
    width?: number
    height?: number
    depth: number
    safeZ: number
    feedXY: number
    feedZ: number
    stepDown: number
  }): string[] {
    const width = Math.max(5, Math.round((params.width ?? 20) * 1000) / 1000)
    const height = Math.max(5, Math.round((params.height ?? 20) * 1000) / 1000)
    const totalDepth = Math.max(0.5, params.depth)
    const step = Math.max(0.5, Math.min(params.stepDown, totalDepth))
    const passes = Math.ceil(totalDepth / step)
    const stepover = Math.max(1, Math.min(width, height) * 0.2) // 20% stepover

    const lines: string[] = []
    lines.push(`; Pocket: ${width} x ${height} mm, depth ${totalDepth} mm, stepover ${stepover.toFixed(3)} mm`)
    for (let i = 1; i <= passes; i++) {
      const z = -Math.min(i * step, totalDepth)
      lines.push(`; Pocket pass ${i}/${passes} to Z${z.toFixed(3)}`)
      let y = 0
      let direction: 'right' | 'left' = 'right'
      lines.push(`G0 X0 Y0`)
      lines.push(`G1 Z${z.toFixed(3)} F${params.feedZ}`)
      while (y <= height) {
        if (direction === 'right') {
          lines.push(`G1 X${width.toFixed(3)} Y${y.toFixed(3)} F${params.feedXY}`)
        } else {
          lines.push(`G1 X0 Y${y.toFixed(3)} F${params.feedXY}`)
        }
        y += stepover
        lines.push(`G1 Y${Math.min(y, height).toFixed(3)} F${params.feedXY}`)
        direction = direction === 'right' ? 'left' : 'right'
      }
      lines.push(`G0 Z${params.safeZ.toFixed(3)}`)
    }
    return lines
  }

  private generateCircleProfile(params: {
    radius?: number
    depth: number
    safeZ: number
    feedXY: number
    feedZ: number
    stepDown: number
  }): string[] {
    const radius = Math.max(1, Math.round((params.radius ?? 10) * 1000) / 1000)
    const totalDepth = Math.max(0.5, params.depth)
    const step = Math.max(0.5, Math.min(params.stepDown, totalDepth))
    const passes = Math.ceil(totalDepth / step)
    const segments = 36 // 10 degree per segment approximation

    const lines: string[] = []
    lines.push(`; Circle profile: R${radius} mm, depth ${totalDepth} mm`)
    for (let i = 1; i <= passes; i++) {
      const z = -Math.min(i * step, totalDepth)
      lines.push(`; Pass ${i}/${passes} to Z${z.toFixed(3)}`)
      // Start point at angle 0 on circumference
      lines.push(`G0 X${radius.toFixed(3)} Y0`)
      lines.push(`G1 Z${z.toFixed(3)} F${params.feedZ}`)
      for (let s = 1; s <= segments; s++) {
        const angle = (2 * Math.PI * s) / segments
        const x = radius * Math.cos(angle)
        const y = radius * Math.sin(angle)
        lines.push(`G1 X${x.toFixed(3)} Y${y.toFixed(3)} F${params.feedXY}`)
      }
      lines.push(`G0 Z${params.safeZ.toFixed(3)}`)
    }
    return lines
  }

  private generateDrillPattern(params: {
    holes?: number
    rows?: number
    cols?: number
    spacing?: number
    depth: number
    safeZ: number
    feedZ: number
  }): string[] {
    const rows = Math.max(1, params.rows ?? Math.ceil(Math.sqrt(params.holes ?? 1)))
    const cols = Math.max(1, params.cols ?? Math.ceil((params.holes ?? 1) / rows))
    const spacing = Math.max(5, Math.round((params.spacing ?? 20) * 1000) / 1000)
    const totalHoles = params.holes ?? rows * cols
    const lines: string[] = []
    lines.push(`; Drill pattern: ${totalHoles} holes, ${rows}x${cols}, spacing ${spacing} mm, depth ${params.depth} mm`)
    let count = 0
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        if (count >= totalHoles) break
        const x = c * spacing
        const y = r * spacing
        lines.push(`; Hole ${count + 1}`)
        lines.push(`G0 X${x.toFixed(3)} Y${y.toFixed(3)} Z${params.safeZ.toFixed(3)}`)
        lines.push(`G1 Z${(-Math.abs(params.depth)).toFixed(3)} F${params.feedZ}`)
        lines.push(`G0 Z${params.safeZ.toFixed(3)}`)
        count += 1
      }
    }
    return lines
  }

  private async saveGcodeToFile(gcode: string, hint: string): Promise<string> {
    const nikCliDir = path.join(this.workingDirectory, '.nikcli')
    const gcodeDir = path.join(nikCliDir, 'gcode')
    await fs.mkdir(gcodeDir, { recursive: true })
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
    const slug = (hint || 'job')
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '_')
      .replace(/^_+|_+$/g, '')
      .substring(0, 24)
    const filename = `tool_${slug || 'gcode'}_${timestamp}.gcode`
    const fullPath = path.join(gcodeDir, filename)
    await fs.writeFile(fullPath, gcode, 'utf8')
    console.log(chalk.green(`✅ G-code saved to: ${fullPath}`))
    return path.join('.nikcli', 'gcode', filename)
  }
}

export default TextToGCodeTool
