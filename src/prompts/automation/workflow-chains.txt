WORKFLOW AUTOMATION - TOOL CHAINS

System to execute automatic tool call chains to achieve complex objectives.

## PRINCIPLES OF CHAINS

1. **SEQUENTIALITY**: Each tool call depends on the result of the previous one
2. **AUTONOMY**: Automatic execution without human intervention for safe tasks
3. **TRANSPARENCY**: Detailed log of each step of the chain
4. **RECOVERY**: Error handling and automatic retries
5. **BRANCHING**: Conditional chains based on results

## TYPES OF CHAINS

### ANALYSIS-IMPLEMENTATION CHAIN
```
1. read-file-tool → Analyze existing code
2. grep-search → Find patterns and dependencies  
3. write-file-tool → Create new files
4. replace-in-file-tool → Modify existing files
5. run-command-tool → Test implementation
```

### REFACTORING CHAIN
```
1. grep-search → Find all occurrences
2. read-file-tool → Analyze each file
3. replace-in-file-tool → Apply changes
4. run-command-tool → Verify that everything works
5. write-file-tool → Update documentation
```

### TESTING CHAIN
```
1. read-file-tool → Analyze code to be tested
2. write-file-tool → Create test files
3. run-command-tool → Execute tests
4. replace-in-file-tool → Fix any errors
5. run-command-tool → Re-run tests until success
```

### DEPLOYMENT CHAIN
```
1. run-command-tool → Build the project
2. run-command-tool → Run test suite
3. read-file-tool → Verify configurations
4. run-command-tool → Deploy
5. run-command-tool → Health check post-deploy
```

## AUTOMATION PATTERNS

### AUTO-APPROVAL RULES
- Standard CRUD operations → AUTO-APPROVE
- Test execution → AUTO-APPROVE  
- File reads/analysis → AUTO-APPROVE
- Build operations → AUTO-APPROVE
- Schema changes → REQUIRE APPROVAL
- Delete operations → REQUIRE APPROVAL
- External API calls → REQUIRE APPROVAL

### RETRY LOGIC
```
IF tool_call_fails:
  IF retry_count < 3:
    WAIT exponential_backoff
    RETRY with adjusted parameters
  ELSE:
    ESCALATE to human review
```

### BRANCHING CONDITIONS
```
IF test_results == "PASS":
  CONTINUE to deployment chain
ELSE:
  BRANCH to fix-and-retry chain
```

## EXAMPLES OF COMPLETE CHAINS

### EXAMPLE 1: Add new feature
```
GOAL: Implement login with Google OAuth

CHAIN:
1. read-file-tool("package.json") → Verify dependencies
2. run-command-tool("npm install passport passport-google-oauth20") → Install deps
3. write-file-tool("src/auth/google-strategy.js") → Create OAuth strategy
4. read-file-tool("src/app.js") → Analyze main app
5. replace-in-file-tool("src/app.js") → Integrate OAuth middleware
6. write-file-tool("src/routes/auth.js") → Create authentication route
7. write-file-tool("tests/auth.test.js") → Create test
8. run-command-tool("npm test") → Verify implementation
9. write-file-tool("docs/oauth-setup.md") → Update documentation
```

### EXAMPLE 2: Global refactoring
```
GOAL: Rename function getUserData → fetchUserProfile

CHAIN:
1. grep-search("getUserData", recursive=true) → Find all occurrences
2. FOR EACH file_found:
   a. read-file-tool(file_path) → Analyze context
   b. replace-in-file-tool(file_path, "getUserData", "fetchUserProfile")
3. grep-search("getUserData", recursive=true) → Verify completion
4. run-command-tool("npm test") → Verify that everything works
5. run-command-tool("npm run lint") → Verify code style
```

### EXAMPLE 3: Complete project setup
```
GOAL: Setup new React project with TypeScript

CHAIN:
1. run-command-tool("npx create-react-app . --template typescript")
2. run-command-tool("npm install @types/react @types/react-dom")
3. write-file-tool("src/components/App.tsx") → Main component
4. write-file-tool("src/hooks/useApi.ts") → Custom hook
5. write-file-tool("src/utils/constants.ts") → Constants
6. replace-in-file-tool("src/index.tsx") → Initial setup
7. write-file-tool("tests/App.test.tsx") → Test component
8. run-command-tool("npm test") → Verify setup
9. run-command-tool("npm start") → Start dev server
```

## MONITORING AND LOGGING

Each chain must log:
- Start/end timestamp
- Tool calls executed with parameters
- Results of each step
- Errors and retry attempts
- Total execution time
- Success metrics

## SAFETY MECHANISMS

- Dry-run mode for previewing actions
- Automatic rollback in case of critical errors
- Automatic backup before important changes
- Rate limiting to avoid tool call spam
- Human escalation for risky operations
