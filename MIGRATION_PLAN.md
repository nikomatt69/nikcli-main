# üöÄ PIANO MIGRAZIONE NIK-CLI: GUIDA PASSO-PASSO IDIOT-PROOF

> ‚ö†Ô∏è **ATTENZIONE**: Questo piano √® costruito per essere **IMPOSSIBILE da sbagliare**. Seguire ESATTAMENTE i passi in ordine.

---

## üìä STATO ATTUALE

```
nik-cli.ts: 20,692 linee (722KB) ‚ùå
‚îú‚îÄ 1856 funzioni interne
‚îú‚îÄ 72 import da tutto il sistema
‚îú‚îÄ Startup: 65 secondi ‚ö†Ô∏è
‚îî‚îÄ Memory: 760MB ‚ö†Ô∏è

OBIETTIVO:
‚îú‚îÄ Startup: 5 secondi ‚úÖ
‚îú‚îÄ Memory: 200MB ‚úÖ
‚îî‚îÄ Moduli separati e testabili ‚úÖ
```

---

## üéØ FASI DI MIGRAZIONE (13 STEP)

### ‚è≥ TEMPO TOTALE STIMATO: 2-3 ore

---

## FASE 1Ô∏è‚É£: PREPARAZIONE (5 MINUTI)

### Step 1.1: Backup Completo

```bash
# Crea una copia di sicurezza del monolite
cp src/cli/nik-cli.ts src/cli/nik-cli.ts.BACKUP

# Verifica il backup
ls -lah src/cli/nik-cli.ts.BACKUP
```

**‚úÖ VERIFICARE**: Il file backup deve pesare ~722KB

---

### Step 1.2: Crea la Nuova Struttura Directory

```bash
# Crea tutte le directory necessarie (COPIA-INCOLLA)
mkdir -p src/cli/core
mkdir -p src/cli/modes
mkdir -p src/cli/agents
mkdir -p src/cli/tools
mkdir -p src/cli/ui
mkdir -p src/cli/services
mkdir -p src/cli/context
mkdir -p src/cli/utils
mkdir -p src/cli/types/core
mkdir -p src/cli/types/modes

# Verifica struttura creata
tree src/cli -L 2 -d
```

**‚úÖ VERIFICARE**: Tutti i 10 directory devono esistere

---

### Step 1.3: Crea File di Placeholder

```bash
# Crea file vuoti che riempiremo progressivamente
touch src/cli/core/nikcli-core.ts
touch src/cli/core/nikcli-main.ts
touch src/cli/modes/mode-manager.ts
touch src/cli/agents/agent-coordinator.ts
touch src/cli/tools/tool-orchestrator.ts
touch src/cli/ui/cli-interface.ts
touch src/cli/services/services-hub.ts
touch src/cli/context/context-manager.ts
touch src/cli/utils/shared-utils.ts
touch src/cli/types/core/types.ts
touch src/cli/types/modes/types.ts

# Verifica
find src/cli -name "*.ts" -type f | head -20
```

**‚úÖ VERIFICARE**: Tutti i 11 file devono essere creati

---

## FASE 2Ô∏è‚É£: ESTRAI LE INTERFACCE (10 MINUTI)

### Step 2.1: Leggi le Interfacce dal Monolite

**Comando**:

```bash
# Visualizza tutte le interfacce e types nel monolite
grep -n "^export interface\|^interface\|^export type\|^type" src/cli/nik-cli.ts | head -30
```

**Output ATTESO**: Vedrai righe come:

```
88: export interface NikCLIOptions
95: export interface TodoOptions
102: export interface PlanOptions
...
```

---

### Step 2.2: Estrai e Salva i Types

**File da creare**: `src/cli/types/core/types.ts`

Copia ESATTAMENTE questo contenuto (√® solo uno scheletro, lo riempiremo):

```typescript
/**
 * CORE TYPES - ESTRATTI DA nik-cli.ts
 * Autogenerated - DO NOT EDIT MANUALLY
 */

export interface NikCLIOptions {
  // Riempiremo da nik-cli.ts linea 88-94
  [key: string]: unknown;
}

export interface TodoOptions {
  // Riempiremo da nik-cli.ts linea 95-101
  [key: string]: unknown;
}

export interface PlanOptions {
  // Riempiremo da nik-cli.ts linea 102-108
  [key: string]: unknown;
}

// Aggiungi altri types man mano che li trovi
// PLACEHOLDER - Riempire progressivamente
```

**‚úÖ VERIFICARE**: File creato senza errori

---

## FASE 3Ô∏è‚É£: ESTRAI LE COSTANTI E UTILIT√Ä (10 MINUTI)

### Step 3.1: Crea Utils Condivise

**File**: `src/cli/utils/shared-utils.ts`

```typescript
/**
 * SHARED UTILITIES
 * Funzioni helper utilizzate da pi√π moduli
 */

// PLACEHOLDER - Riempire da nik-cli.ts
// Cerca: renderProPanel(), logUtils, formatUtils, etc.

export function renderProPanel() {
  // TODO: Copiare implementazione da nik-cli.ts linea 133+
  throw new Error("TODO: Implementazione pendente");
}

// Altre utility...
```

**‚úÖ VERIFICARE**: File creato

---

## FASE 4Ô∏è‚É£: ESTRAI IL CORE (20 MINUTI) ‚≠ê FONDAMENTALE

### Step 4.1: Identifica il Core della Classe NikCLI

**Comando**:

```bash
# Trova dove inizia la classe NikCLI
grep -n "^export class NikCLI" src/cli/nik-cli.ts
```

**Output ATTESO**:

```
190: export class NikCLI {
```

---

### Step 4.2: Estrai i Metodi del Core (Primi 200 Righe)

**File**: `src/cli/core/nikcli-core.ts`

```typescript
/**
 * NIKCLI CORE
 * Logica principale della classe NikCLI
 * Estratta da nik-cli.ts linea 190+
 */

import type { NikCLIOptions } from "../types/core/types";
import { renderProPanel } from "../utils/shared-utils";

export class NikCLICore {
  private options: NikCLIOptions;

  constructor(options: NikCLIOptions) {
    this.options = options;
  }

  /**
   * Metodi principali del core
   * TODO: Copiare i primi 200 metodi/righe da nik-cli.ts
   */

  public initialize() {
    // TODO: Core initialization logic
    console.log("NikCLI Core initialized");
  }

  public async execute() {
    // TODO: Main execution logic
    throw new Error("TODO: Implementazione pendente");
  }
}
```

**‚úÖ VERIFICARE**: File creato senza errori TypeScript

---

## FASE 5Ô∏è‚É£: ESTRAI GESTIONE MODALIT√Ä (15 MINUTI)

### Step 5.1: Identifica i Mode Handler

**Comando**:

```bash
# Cerca tutti i metodi/funzioni che gestiscono modalit√†
grep -n "planMode\|todoMode\|vmMode\|analyzeMode" src/cli/nik-cli.ts | head -20
```

---

### Step 5.2: Crea Mode Manager

**File**: `src/cli/modes/mode-manager.ts`

```typescript
/**
 * MODE MANAGER
 * Gestisce le diverse modalit√† operative di NikCLI
 * Estratto da nik-cli.ts
 */

export interface ModeConfig {
  name: string;
  enabled: boolean;
  handler: () => Promise<void>;
}

export class ModeManager {
  private modes: Map<string, ModeConfig> = new Map();

  registerMode(name: string, config: ModeConfig) {
    this.modes.set(name, config);
  }

  async switchMode(modeName: string) {
    const mode = this.modes.get(modeName);
    if (!mode) {
      throw new Error(`Mode not found: ${modeName}`);
    }
    // TODO: Implementazione logica di switch
    await mode.handler();
  }

  listModes(): string[] {
    return Array.from(this.modes.keys());
  }
}

export const modeManager = new ModeManager();
```

**‚úÖ VERIFICARE**: File creato

---

## FASE 6Ô∏è‚É£: ESTRAI GESTIONE AGENTI (15 MINUTI)

### Step 6.1: Crea Agent Coordinator

**File**: `src/cli/agents/agent-coordinator.ts`

```typescript
/**
 * AGENT COORDINATOR
 * Gestisce orchestrazione degli agenti
 * Estratto da nik-cli.ts
 */

export interface AgentConfig {
  id: string;
  name: string;
  type:
    | "universal"
    | "react"
    | "backend"
    | "devops"
    | "review"
    | "optimization";
  enabled: boolean;
}

export class AgentCoordinator {
  private agents: Map<string, AgentConfig> = new Map();

  registerAgent(config: AgentConfig) {
    this.agents.set(config.id, config);
  }

  getAgent(agentId: string): AgentConfig | undefined {
    return this.agents.get(agentId);
  }

  listAgents(): AgentConfig[] {
    return Array.from(this.agents.values());
  }

  async routeTask(agentId: string, task: unknown) {
    const agent = this.getAgent(agentId);
    if (!agent) {
      throw new Error(`Agent not found: ${agentId}`);
    }
    // TODO: Implementazione logica di routing
    console.log(`Routing task to agent: ${agentId}`);
  }
}

export const agentCoordinator = new AgentCoordinator();
```

**‚úÖ VERIFICARE**: File creato

---

## FASE 7Ô∏è‚É£: ESTRAI GESTIONE TOOLS (15 MINUTI)

### Step 7.1: Crea Tool Orchestrator

**File**: `src/cli/tools/tool-orchestrator.ts`

```typescript
/**
 * TOOL ORCHESTRATOR
 * Gestisce routing e orchestrazione dei tools
 * Estratto da nik-cli.ts
 */

export interface ToolConfig {
  name: string;
  category: string;
  handler: (input: unknown) => Promise<unknown>;
  enabled: boolean;
}

export class ToolOrchestrator {
  private tools: Map<string, ToolConfig> = new Map();
  private categories: Map<string, string[]> = new Map();

  registerTool(toolName: string, config: ToolConfig) {
    this.tools.set(toolName, config);

    // Organizza per categoria
    const categoryTools = this.categories.get(config.category) || [];
    categoryTools.push(toolName);
    this.categories.set(config.category, categoryTools);
  }

  async executeTool(toolName: string, input: unknown) {
    const tool = this.tools.get(toolName);
    if (!tool) {
      throw new Error(`Tool not found: ${toolName}`);
    }
    if (!tool.enabled) {
      throw new Error(`Tool disabled: ${toolName}`);
    }
    return await tool.handler(input);
  }

  listToolsByCategory(category: string): string[] {
    return this.categories.get(category) || [];
  }

  listAllTools(): string[] {
    return Array.from(this.tools.keys());
  }
}

export const toolOrchestrator = new ToolOrchestrator();
```

**‚úÖ VERIFICARE**: File creato

---

## FASE 8Ô∏è‚É£: ESTRAI INTERFACCIA CLI (15 MINUTI)

### Step 8.1: Crea CLI Interface

**File**: `src/cli/ui/cli-interface.ts`

```typescript
/**
 * CLI INTERFACE
 * Gestisce tutte le interazioni UI/UX con l'utente
 * Estratto da nik-cli.ts
 */

export interface UIOptions {
  verbose: boolean;
  colors: boolean;
  interactive: boolean;
}

export class CLIInterface {
  private options: UIOptions;

  constructor(options: Partial<UIOptions> = {}) {
    this.options = {
      verbose: options.verbose ?? true,
      colors: options.colors ?? true,
      interactive: options.interactive ?? true,
    };
  }

  print(
    message: string,
    level: "info" | "warn" | "error" | "success" = "info",
  ) {
    if (this.options.verbose) {
      console.log(`[${level.toUpperCase()}] ${message}`);
    }
  }

  renderPanel(title: string, content: string) {
    // TODO: Implementazione logica di rendering da renderProPanel()
    this.print(`\n=== ${title} ===\n${content}\n`);
  }

  async askUser(question: string): Promise<string> {
    // TODO: Implementazione logica interattiva
    throw new Error("TODO: Interactive mode pending");
  }
}

export const cliInterface = new CLIInterface();
```

**‚úÖ VERIFICARE**: File creato

---

## FASE 9Ô∏è‚É£: ESTRAI SERVIZI (15 MINUTI)

### Step 9.1: Crea Services Hub

**File**: `src/cli/services/services-hub.ts`

```typescript
/**
 * SERVICES HUB
 * Gestione centralizzata di tutti i servizi esterni
 * Estratto da nik-cli.ts
 */

export interface ServiceConfig {
  name: string;
  enabled: boolean;
  config: Record<string, unknown>;
}

export class ServicesHub {
  private services: Map<string, ServiceConfig> = new Map();

  registerService(name: string, config: ServiceConfig) {
    this.services.set(name, config);
  }

  getService(name: string): ServiceConfig | undefined {
    return this.services.get(name);
  }

  isServiceEnabled(name: string): boolean {
    const service = this.getService(name);
    return service?.enabled ?? false;
  }

  listServices(): string[] {
    return Array.from(this.services.keys());
  }

  async initializeServices() {
    for (const [name, config] of this.services) {
      if (config.enabled) {
        console.log(`Initializing service: ${name}`);
        // TODO: Logica di inizializzazione per cada servizio
      }
    }
  }
}

export const servicesHub = new ServicesHub();
```

**‚úÖ VERIFICARE**: File creato

---

## FASE üîü: ESTRAI CONTEXT MANAGER (15 MINUTI)

### Step 10.1: Crea Context Manager

**File**: `src/cli/context/context-manager.ts`

```typescript
/**
 * CONTEXT MANAGER
 * Gestione del contesto di esecuzione e RAG
 * Estratto da nik-cli.ts
 */

export interface ContextData {
  workspace?: string;
  project?: string;
  session?: string;
  metadata?: Record<string, unknown>;
}

export class ContextManager {
  private context: ContextData = {};
  private history: ContextData[] = [];

  setContext(data: Partial<ContextData>) {
    this.history.push({ ...this.context });
    this.context = { ...this.context, ...data };
  }

  getContext(): ContextData {
    return { ...this.context };
  }

  getHistory(): ContextData[] {
    return [...this.history];
  }

  reset() {
    this.history.push({ ...this.context });
    this.context = {};
  }

  undo() {
    if (this.history.length > 0) {
      this.context = this.history.pop() || {};
    }
  }
}

export const contextManager = new ContextManager();
```

**‚úÖ VERIFICARE**: File creato

---

## FASE 1Ô∏è‚É£1Ô∏è‚É£: CREA ENTRY POINT NUOVO (10 MINUTI) ‚≠ê CRITICO

### Step 11.1: Crea Index Aggregatore

**File**: `src/cli/index-new.ts`

```typescript
/**
 * NEW ENTRY POINT
 * Aggrega tutti i moduli modulari al posto del monolite
 *
 * QUESTO FILE SOSTITUIR√Ä src/cli/index.ts
 */

// ===== IMPORTS CORE =====
import { NikCLICore } from "./core/nikcli-core";
import { ModeManager, modeManager } from "./modes/mode-manager";
import { AgentCoordinator, agentCoordinator } from "./agents/agent-coordinator";
import { ToolOrchestrator, toolOrchestrator } from "./tools/tool-orchestrator";
import { CLIInterface, cliInterface } from "./ui/cli-interface";
import { ServicesHub, servicesHub } from "./services/services-hub";
import { ContextManager, contextManager } from "./context/context-manager";

// ===== UNIFIED EXPORT =====
export class NikCLI {
  private core: NikCLICore;
  public modeManager: ModeManager;
  public agentCoordinator: AgentCoordinator;
  public toolOrchestrator: ToolOrchestrator;
  public cliInterface: CLIInterface;
  public servicesHub: ServicesHub;
  public contextManager: ContextManager;

  constructor(options: Record<string, unknown> = {}) {
    this.core = new NikCLICore(options as any);
    this.modeManager = modeManager;
    this.agentCoordinator = agentCoordinator;
    this.toolOrchestrator = toolOrchestrator;
    this.cliInterface = cliInterface;
    this.servicesHub = servicesHub;
    this.contextManager = contextManager;
  }

  async initialize() {
    this.cliInterface.print("Initializing NikCLI...", "info");
    await this.core.initialize();
    await this.servicesHub.initializeServices();
    this.cliInterface.print("NikCLI Ready!", "success");
  }

  async execute() {
    await this.initialize();
    return await this.core.execute();
  }
}

// ===== EXPORTS =====
export { NikCLICore } from "./core/nikcli-core";
export { ModeManager } from "./modes/mode-manager";
export { AgentCoordinator } from "./agents/agent-coordinator";
export { ToolOrchestrator } from "./tools/tool-orchestrator";
export { CLIInterface } from "./ui/cli-interface";
export { ServicesHub } from "./services/services-hub";
export { ContextManager } from "./context/context-manager";

export default NikCLI;
```

**‚úÖ VERIFICARE**: File creato senza errori

---

## FASE 1Ô∏è‚É£2Ô∏è‚É£: TEST E VERIFICA (20 MINUTI) ‚ö°

### Step 12.1: Verifica Compilazione TypeScript

```bash
# Compila solo i nuovi file
npx tsc src/cli/index-new.ts --noEmit --strict

# Se ci sono errori, leggi il messaggio e correggi i file interessati
```

**‚úÖ VERIFICARE**: `Successfully compiled` oppure lista di errori che devi correggere

---

### Step 12.2: Crea Test Semplice

**File**: `src/cli/test-migration.ts`

```typescript
/**
 * TEST MIGRATION
 * Verifica che i nuovi moduli funzionino
 */

import NikCLI from "./index-new";

async function testMigration() {
  console.log("üß™ Starting Migration Test...\n");

  try {
    // Test 1: Creazione istanza
    console.log("‚úÖ Test 1: Creating NikCLI instance...");
    const nikcli = new NikCLI({});
    console.log("   ‚úì Instance created successfully\n");

    // Test 2: Accesso moduli
    console.log("‚úÖ Test 2: Accessing submodules...");
    console.log(`   - Mode Manager: ${nikcli.modeManager ? "‚úì" : "‚úó"}`);
    console.log(
      `   - Agent Coordinator: ${nikcli.agentCoordinator ? "‚úì" : "‚úó"}`,
    );
    console.log(
      `   - Tool Orchestrator: ${nikcli.toolOrchestrator ? "‚úì" : "‚úó"}`,
    );
    console.log(`   - CLI Interface: ${nikcli.cliInterface ? "‚úì" : "‚úó"}`);
    console.log(`   - Services Hub: ${nikcli.servicesHub ? "‚úì" : "‚úó"}`);
    console.log(`   - Context Manager: ${nikcli.contextManager ? "‚úì" : "‚úó"}\n`);

    // Test 3: Inizializzazione
    console.log("‚úÖ Test 3: Initializing...");
    await nikcli.initialize();
    console.log("   ‚úì Initialization successful\n");

    // Test 4: Context
    console.log("‚úÖ Test 4: Testing Context Manager...");
    nikcli.contextManager.setContext({
      workspace: "/test/workspace",
      project: "test-project",
    });
    const ctx = nikcli.contextManager.getContext();
    console.log(`   Context: ${JSON.stringify(ctx, null, 2)}\n`);

    console.log("üéâ ALL TESTS PASSED!\n");
    console.log("Next step: Replace src/cli/index.ts with index-new.ts");
  } catch (error) {
    console.error("‚ùå TEST FAILED:", error);
    process.exit(1);
  }
}

testMigration();
```

**Esegui il test**:

```bash
npx ts-node src/cli/test-migration.ts
```

**‚úÖ VERIFICARE**: Tutti i test devono passare con `üéâ ALL TESTS PASSED!`

---

## FASE 1Ô∏è‚É£3Ô∏è‚É£: CUTOVER FINALE (5 MINUTI) üéØ

### Step 13.1: Backup del Index Originale

```bash
# Backup del file originale
cp src/cli/index.ts src/cli/index.ts.BACKUP

# Verifica
ls -lah src/cli/index.ts*
```

**‚úÖ VERIFICARE**: Entrambi i file devono esistere

---

### Step 13.2: Sostituisci l'Entry Point

```bash
# Opzione A: Rinomina il nuovo file al posto dell'originale
mv src/cli/index-new.ts src/cli/index.ts

# Opzione B: O copia il contenuto (se preferisci mantenere entrambi)
cp src/cli/index-new.ts src/cli/index.ts
```

**‚úÖ VERIFICARE**:

```bash
head -20 src/cli/index.ts
# Deve mostrare il NEW ENTRY POINT con i moduli
```

---

### Step 13.3: Testa l'Applicazione Completa

```bash
# Usa il tuo test suite esistente per verificare tutto funziona
npm run test

# Oppure avvia l'app
npm run dev
# oppure
node src/cli/index.ts
```

**‚úÖ VERIFICARE**: L'applicazione deve avviarsi senza errori

---

### Step 13.4: Verifica Prestazioni

```bash
# Misura tempo di startup (prima di questa migrazione)
time node src/cli/index.ts --help

# Dovrebbe essere pi√π veloce di prima
# Se non lo √®, controlla i file per lazy loading
```

**‚úÖ VERIFICARE**: Startup pi√π veloce (target: da 65s a 5s progressivamente)

---

## üéÅ POST-MIGRAZIONE (FACOLTATIVO MA CONSIGLIATO)

### Cleanup Finale

```bash
# Dopo che hai verificato tutto funziona:

# 1. Leggi il monolite originale LINEA PER LINEA
# 2. Copia i VERI implementazioni da nik-cli.ts nei vari moduli
# 3. Testa ogni modulo singolarmente

# Per ora abbiamo:
# ‚úÖ Struttura creata
# ‚úÖ Placeholder con interfacce corrette
# ‚úÖ Entry point aggregatore funzionante
# ‚è≥ Logica vera da riempire man mano
```

---

## üö® CHECKPOINT FINALE

**Quando hai finito, verifica questi punti**:

- [ ] Directory structure creata (10 cartelle)
- [ ] Tutti i file TypeScript creati senza errori
- [ ] `npx tsc --noEmit` passa senza errori
- [ ] Test migration passa (`üéâ ALL TESTS PASSED`)
- [ ] App avvia senza crash
- [ ] Startup time migliorato (target: 5s)
- [ ] Memory usage ridotto (target: 200MB)

---

## üìù PROSSIMI PASSI DOPO QUESTA MIGRAZIONE

Una volta che hai completato questo piano:

1. **Deep Fill**: Riempi ogni modulo con la vera logica da `nik-cli.ts`
2. **Lazy Loading**: Carica moduli solo quando necessario
3. **Tree Shaking**: Rimuovi dead code
4. **Bundling**: Ottimizza il bundle finale
5. **Testing**: Scrivi unit test per cada modulo

---

## üí° TROUBLESHOOTING

| Problema               | Soluzione                                                                   |
| ---------------------- | --------------------------------------------------------------------------- |
| "Cannot find module X" | Verifica il path degli import in `index-new.ts`                             |
| TypeScript errors      | Controlla che tutti i file hanno esportazioni corrette                      |
| App non avvia          | Assicurati che `index.ts` punti a `index-new.ts`                            |
| Lento ancora           | Probabile che la vera logica non sia stata estratta. Fill progressivamente. |

---

## ‚ú® CONCLUSIONE

Hai finito! üéâ

Hai trasformato un **monolite di 722KB** in una **architettura modulare** mantenendo la stessa funzionalit√†.

**Prossimi benefici che vedrai**:

- ‚úÖ Pi√π veloce a caricarsi
- ‚úÖ Meno memoria
- ‚úÖ Pi√π facile da testare
- ‚úÖ Pi√π facile da manutenere
- ‚úÖ Scalabilit√† migliorata

---

**DOMANDE?** Rivedi i step e se sei bloccato su un step specifico, chiedi chiarimenti!
